from flask import Flask, request, jsonify, render_template
import re, os, json, threading, random, webbrowser
from threading import Timer
from dotenv import load_dotenv
from werkzeug.exceptions import HTTPException
from googletrans import Translator


# --- Local Imports ---
from name_recognition import check_name
from cli_assistant import cli_intro_sequence
from book_recommender import handle_book_recommendation, get_video_lists
from budget_tracker import start_budget_tracking
from depression_checker import handle_depression_screening_step
from math_processor import process_query
from house_helper import house_tidying, match_topic_to_category
from language_mode import language_translation_mode_backend
from memory_logger import MemoryLogger, BeliefModel
from reminder_manager import ReminderManager

# --- Environment & Globals ---
load_dotenv()
YOUTUBE_API_KEY = os.getenv('YT_IFYKYK')

app = Flask(__name__)

user_sessions = {}
SESSION_FILE = 'user_sessions.json'
translator = Translator()


# ---------------- Helper Functions ------------------

@app.route("/api/book_categories")
def book_categories():
    categories = sorted(get_video_lists().keys())
    return jsonify({"categories": categories})

def sanitize_username(name: str) -> str:
    return re.sub(r'[^a-zA-Z0-9_]', '', name)

def load_sessions():
    global user_sessions
    try:
        with open(SESSION_FILE, 'r') as f:
            content = f.read().strip()
            if content:
                user_sessions = json.loads(content)
                for key, session in user_sessions.items():
                    session['memory_logger'] = MemoryLogger(key, BeliefModel(key))
            else:
                user_sessions = {}
    except (FileNotFoundError, json.JSONDecodeError):
        user_sessions = {}

def save_sessions():
    try:
        serializable_sessions = {
            k: {ik: iv for ik, iv in v.items() if ik != 'memory_logger'}
            for k, v in user_sessions.items()
        }
        with open(SESSION_FILE, 'w') as f:
            json.dump(serializable_sessions, f, indent=4)
    except Exception as e:
        print(f"[save_sessions] Failed: {e}")

def get_memory_logger(user_id):
    session = user_sessions.get(user_id)
    if not session:
        user_sessions[user_id] = {'memory_logger': MemoryLogger(user_id, BeliefModel(user_id))}
    return user_sessions[user_id]['memory_logger']



# ----------------- User Session Routes ------------------

@app.route("/create_session", methods=["POST"])
def create_session():
    data = request.get_json(force=True)
    name = (data.get('name') or "").strip()
    if not name:
        return jsonify({"success": False, "error": "Name is required."}), 400

    user_id = sanitize_username(name)
    memory_logger = MemoryLogger(user_id, BeliefModel(user_id))
    reminder_manager = ReminderManager(user_id)

    user_sessions[user_id] = {
        "display_name": name,
        "user_id": user_id,
        "memory_logger": memory_logger,
        "reminder_manager": reminder_manager
    }
    save_sessions()
    return jsonify({"success": True, "userId": user_id})

# ----------------- Mode Handlers ------------------

def handle_mode_1(user_input, memory_logger):
    response = check_name(user_input, memory_logger)
    memory_logger.log_interaction(user_input, response, tags=["name_recognition"])
    return {"success": True, "response": response}


def handle_mode_book(user_id, memory_logger, data):
    topic = (data.get("topic") or data.get("input") or "").strip()
    category = (data.get("category") or "").strip().lower()
    choice = str(data.get("choice") or "3").strip()

    valid_categories = {k.lower() for k in get_video_lists().keys()}
    if category not in valid_categories:
        return {"success": False, "error": f"Invalid category '{category}'. Valid: {', '.join(valid_categories)}"}

    results = handle_book_recommendation(user_id, memory_logger, topic, choice, category)
    response_lines = ["Here are your recommendations:"]
    if results.get("book"):
        book = results["book"]
        response_lines.append(f"üìò Book: {book.get('title')} by {book.get('author')}")
    if results.get("audiobooks"):
        response_lines.append("üéß Audiobooks:")
        for a in results["audiobooks"]:
            response_lines.append(f"- {a['title']}")
    response_text = "\n".join(response_lines)

    memory_logger.log_interaction(f"Book request: {topic} ({category})", response_text, tags=["book"])
    return {"success": True, "response": response_text, "book": results.get("book"), "audiobooks": results.get("audiobooks")}


def handle_mode_budget(user_id, session, user_input):
    memory_logger = session.get('memory_logger')
    if "budget_gen" not in session:
        budget_gen = start_budget_tracking(user_id, memory_logger)
        session["budget_gen"] = budget_gen
        try:
            output = next(budget_gen)
        except StopIteration:
            output = "Budget tracker exited immediately."
            session.pop("budget_gen", None)
        memory_logger.log_interaction("Start Budget Tracker", output, tags=["budget"])
        return {"success": True, "response": output}
    else:
        budget_gen = session["budget_gen"]
        try:
            output = budget_gen.send(user_input)
        except StopIteration:
            output = "Exiting Budget Tracker."
            session.pop("budget_gen", None)
        memory_logger.log_interaction(user_input, output, tags=["budget"])
        return {"success": True, "response": output}


def handle_mode_depression(session, user_input, memory_logger):
    step = session.get("depression_step", 0)
    answers = session.get("depression_answers", [])
    if not user_input.strip():
        result = handle_depression_screening_step(step, answers, memory_logger)
    else:
        try:
            answer = int(user_input)
            if answer not in range(4):
                raise ValueError
        except (ValueError, TypeError):
            return {"success": False, "message": "‚ö†Ô∏è Enter a number 0-3.", "done": False, "answers": answers, "next_step": step}
        result = handle_depression_screening_step(step, answer, answers, memory_logger)

    session["depression_answers"] = result.get("answers", answers)
    if not result.get("done"):
        session["depression_step"] = result.get("next_step", step + 1)
    else:
        session.pop("depression_step", None)
        session.pop("depression_answers", None)
    return {k: result.get(k) for k in ["success", "message", "done", "next_step", "answers", "error"]}


def handle_mode_tidy(topic, memory_logger):
    category = match_topic_to_category(topic.lower()) or random.choice(["cleaning", "energy", "security", "organization", "automation"])
    advice = house_tidying(category)
    memory_logger.log_interaction(f"Tidy topic: {topic}", advice, tags=["tidy", category])
    return {"success": True, "response": advice}


def handle_mode_voice(memory_logger):
    try:
        threading.Thread(target=run_voice_assistant_gui, daemon=True).start()
        output = "‚úÖ Voice GUI Assistant launched!"
    except Exception as e:
        output = f"‚ùå Failed to launch GUI: {e}"
    memory_logger.log_interaction("Launch voice assistant", output, tags=["voice_gui"])
    return {"success": True, "response": output}


def handle_mode_logs(memory_logger):
    logs = memory_logger.get_logs()
    return {"success": True, "response": logs}


def handle_mode_reminder(session, user_input, data, memory_logger):
    user_id = session.get("user_id") or data.get("userId") or "unknown_user"
    reminder_manager = session.get("reminder_manager") or ReminderManager(user_id)
    session["reminder_manager"] = reminder_manager

    cmd_parts = user_input.strip().split(" ", 1)
    cmd = cmd_parts[0].lower()
    arg = cmd_parts[1].strip() if len(cmd_parts) > 1 else None

    response = {"success": True, "tasks": [], "response": ""}
    if cmd == "add":
        if not arg:
            response.update({"success": False, "response": "‚ö†Ô∏è Reminder text required."})
        else:
            result = reminder_manager.add_reminder(arg, data.get("dueTime"))
            response["response"] = result["response"]
            response["tasks"] = reminder_manager.view_reminders().get("tasks", [])
    elif cmd == "view":
        tasks = reminder_manager.view_reminders()
        response["tasks"] = tasks.get("tasks", [])
        response["response"] = f"üìã You have {len(response['tasks'])} reminder(s)."
    elif cmd == "check_due":
        result = reminder_manager.check_due_reminders()
        response["tasks"] = result.get("tasks", [])
        response["response"] = result["response"]
    elif cmd == "clear":
        reminder_manager.clear_reminders()
        response["tasks"] = []
        response["response"] = "‚úÖ All reminders cleared."
    else:
        response["success"] = False
        response["response"] = "‚ö†Ô∏è Unknown command. Use 'add', 'view', 'check_due', or 'clear'."

    memory_logger.log_interaction(user_input, response["response"], tags=["reminder", cmd])
    return response


def handle_mode_math(user_input, memory_logger):
    memory_logger.belief_model.reinforce_beliefs(["offer math tips", "show steps", "check calculations"])
    tasks = memory_logger.belief_model.get_strongest_beliefs(top_n=3)
    steps_output = process_query(user_input, "math", memory_logger)
    return {"success": True, "steps_output": steps_output, "tasks": tasks, "current_mode": "math", "recommended_mode": "math"}


# ---------------- Flask Routes ------------------

@app.route('/')
def home():
    return render_template('index.html', categories=sorted(get_video_lists().keys()))


@app.route('/start', methods=['POST'])
def start_assistant():
    data = request.get_json(force=True)
    name = (data.get('name') or "").strip()
    if not name:
        return jsonify({"success": False, "error": "Name is required."}), 400

    user_id = sanitize_username(name)
    if not user_id:
        return jsonify({"success": False, "error": "Invalid name."}), 400

    try:
        user_name, memory_logger, reminder_manager = cli_intro_sequence(name)
        user_sessions[user_id] = {
            "display_name": name,
            "user_id": user_id,
            "memory_logger": memory_logger,
            "reminder_manager": reminder_manager
        }
        save_sessions()
        start_voice_listener(user_id)
        return jsonify({"success": True, "message": f"Assistant started for {name}.", "userId": user_id})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@app.route('/mode', methods=['POST'])
def run_mode():
    data = request.get_json(force=True)
    user_id = data.get("userId")
    mode = str(data.get("mode") or "").lower()
    user_input = (data.get("input") or "").strip()
    topic = (data.get("topic") or user_input).strip()

    if not user_id or not mode:
        return jsonify({"success": False, "error": "Missing userId or mode"}), 400

    session = user_sessions.get(user_id) or {"memory_logger": MemoryLogger(user_id, BeliefModel(user_id))}
    memory_logger = session.get("memory_logger")

    mode_dispatch = {
        "1": lambda: handle_mode_1(user_input, memory_logger),
        "book": lambda: handle_mode_book(user_id, memory_logger, data),
        "budget": lambda: handle_mode_budget(user_id, session, user_input),
        "depression": lambda: handle_mode_depression(session, user_input, memory_logger),
        "tidy": lambda: handle_mode_tidy(topic, memory_logger),
        "voice": lambda: {"success": True, "response": "Voice GUI removed, use live /upload_audio instead."},
        "logs": lambda: handle_mode_logs(memory_logger),
        "reminder": lambda: handle_mode_reminder(session, user_input, data, memory_logger),
        "math": lambda: handle_mode_math(user_input, memory_logger),
        "science": lambda: process_query(user_input, "science", memory_logger),
        "translate": lambda: language_translation_mode_backend(
            user_input=user_input,
            target_lang=data.get("target_lang", "en"),
            user_translate=data.get("user_translate", True),
            memory_logger=memory_logger
        )
    }

    handler = mode_dispatch.get(mode)
    if not handler:
        return jsonify({"success": False, "error": f"Unsupported mode: {mode}"}), 400

    result = handler()
    return jsonify(result)

# ----------------- Flask Frontend ------------------

@app.errorhandler(Exception)
def handle_exception(e):
    if isinstance(e, HTTPException):
        return e
    import traceback
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500

# ----------------- Main ------------------

def open_browser():
    webbrowser.open_new("http://127.0.0.1:5000")

if __name__ == "__main__":
    load_sessions()
    print(f"[main] Loaded {len(user_sessions)} sessions.")

    if os.environ.get("WERKZEUG_RUN_MAIN") == "true":
        Timer(1, open_browser).start()

    print("[main] Starting Flask app (HTTP only, no SocketIO)")
    app.run(host="127.0.0.1", port=5000, debug=True)
